<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Conflict Maps & Timeline - EsfViz Project</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
    <style>
        /* Timeline-specific styles */
        .timeline-container {
            background-color: #f5f5f5;
            padding: 30px;
            margin: 40px auto;
            width: 1200px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .timeline-description {
            margin-top: 20px;
            font-size: 18px;
            line-height: 1.5;
            color: #333;
            text-align: left;
            padding: 20px;
        }

        .map-container {
            background: #ffffff;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .controls-container {
            margin: 20px 0;
            padding: 20px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .play-pause-button {
            background: #b82f2f;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'Fira Sans', sans-serif;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .play-pause-button:hover {
            background: #8a2323;
            transform: translateY(-1px);
        }

        .play-pause-button.playing {
            background: #d32f2f;
        }

        .play-pause-button.playing:hover {
            background: #b71c1c;
        }

        .year-slider {
            width: 300px;
            margin: 0 20px;
        }

        .current-year {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            font-family: 'Roboto Slab', serif;
            min-width: 60px;
        }

        .legend {
            margin: 20px 0;
            padding: 15px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #333;
        }

        .legend-text {
            font-size: 12px;
            font-family: 'Fira Sans', sans-serif;
        }

        .legend-title {
            font-size: 14px;
            font-weight: bold;
            font-family: 'Fira Sans', sans-serif;
            margin-right: 15px;
        }

        /* Connection Map styles */
        .connection-map-container {
            background-color: #f5f5f5;
            padding: 30px;
            margin: 40px auto;
            width: 1200px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .connection-line {
            fill: none;
            stroke-opacity: 0.6;
            pointer-events: none;
        }

        .connection-line:hover {
            stroke-opacity: 1;
        }

        .country-node {
            cursor: pointer;
        }

        .country-node:hover {
            stroke: #333;
            stroke-width: 2px;
        }

        .war-type-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .war-type-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .war-type-line {
            width: 30px;
            height: 3px;
            border-radius: 2px;
        }

        .connection-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Fira Sans', sans-serif;
            pointer-events: none;
            max-width: 350px;
            z-index: 1000;
        }

        .connection-tooltip .war-name {
            font-weight: bold;
            color: #ff9800;
            margin-bottom: 5px;
        }

        .connection-tooltip .war-details {
            font-size: 12px;
            opacity: 0.9;
        }

        /* Map styles */
        .country {
            stroke: #fff;
            stroke-width: 0.5px;
            cursor: pointer;
        }

        .country-with-data {
            stroke: #fff;
            stroke-width: 0.5px;
        }

        .country:hover {
            stroke: #333;
            stroke-width: 2px;
        }

        .map-title {
            font-family: 'Roboto Slab', serif;
            font-size: 20px;
            font-weight: 600;
            fill: #2c3e50;
            text-anchor: middle;
        }

        /* Proportional Symbol Map styles */
        .symbol-map-container {
            background-color: #f5f5f5;
            padding: 30px;
            margin: 40px auto;
            width: 1200px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .basemap-country {
            fill: #e8e8e8;
            stroke: #fff;
            stroke-width: 0.5px;
        }

        .source-circle {
            fill: #b82f2f;
            fill-opacity: 0.7;
            stroke: #8a2323;
            stroke-width: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .source-circle:hover {
            fill-opacity: 0.9;
            stroke-width: 2px;
            r: 1.2;
        }

        .symbol-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Fira Sans', sans-serif;
            pointer-events: none;
            max-width: 300px;
            z-index: 1000;
        }

        .symbol-tooltip .country-name {
            font-weight: bold;
            color: #ff9800;
            margin-bottom: 5px;
        }

        .symbol-legend {
            position: absolute;
            top: 50px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-family: 'Fira Sans', sans-serif;
            font-size: 12px;
        }

        .legend-title-text {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .legend-item-symbol {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .legend-circle {
            margin-right: 10px;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .timeline-container {
                width: 95%;
                padding: 15px;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
            }

            .year-slider {
                width: 250px;
            }

            .legend {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="visualization-nav">
        <div class="nav-container">
            <a href="index.html" class="nav-back">← Back to Home</a>
            <h1 class="nav-title">Global Conflict Maps & Timeline</h1>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="visualization-page">
        <div class="timeline-container">
            <h2>Animated Choropleth: Conflict Deaths Over Time (1989-2024)</h2>
            <p class="timeline-description">
                This interactive animated choropleth map visualizes the evolution of conflict-related deaths 
                across the globe from 1989 to 2024. Each frame represents one year, with countries colored 
                based on the sum of conflict deaths for that year. The color scale is adaptive, recalculating 
                for each year to show relative intensities. Countries with no data appear in gray. Use the 
                controls below to play the animation, pause at specific years, or scrub through the timeline 
                manually with the slider.
            </p>
            
            <!-- Map Container -->
            <div class="map-container">
                <svg id="world-map" width="1000" height="500"></svg>
            </div>

            <!-- Controls Container -->
            <div class="controls-container">
                <div class="controls">
                    <button class="play-pause-button" id="play-pause-btn">▶ Play</button>
                    <input type="range" class="year-slider" id="year-slider" 
                           min="1989" max="2024" value="1989" step="1">
                    <div class="current-year" id="current-year">1989</div>
                </div>
            </div>

            <!-- Legend Container -->
            <div class="legend" id="legend">
                <span class="legend-title">Deaths per Year:</span>
                <!-- Legend items will be dynamically generated -->
            </div>
        </div>

        <!-- Connection Map Section -->
        <div class="connection-map-container">
            <h2>War Connections Map: Countries in Conflict</h2>
            <p class="timeline-description">
                This connection map visualizes the relationships between countries involved in wars together.
                Lines connect countries that participated in the same conflict, with different colors representing
                different types of wars: <strong style="color:#b82f2f">Interstate (INTER)</strong> wars between nations,
                and <strong style="color:#2e7d32">Intrastate (INTRA)</strong> civil or internal conflicts.
                Hover over lines to see war details. Use the year filter to see active conflicts during specific periods.
            </p>
            
            <!-- Connection Map Controls -->
            <div class="controls-container">
                <div class="controls">
                    <label for="connection-year-slider" style="font-family: 'Fira Sans', sans-serif; font-weight: 500;">
                        Filter by Year:
                    </label>
                    <input type="range" class="year-slider" id="connection-year-slider" 
                           min="1816" max="2001" value="1990" step="1">
                    <div class="current-year" id="connection-current-year">1990</div>
                    <button class="play-pause-button" id="show-all-wars-btn">Show All Wars</button>
                </div>
            </div>

            <!-- Connection Map Container -->
            <div class="map-container">
                <svg id="connection-map" width="1000" height="500"></svg>
            </div>

            <!-- War Type Legend -->
            <div class="legend">
                <span class="legend-title">War Types:</span>
                <div class="war-type-legend">
                    <div class="war-type-item">
                        <div class="war-type-line" style="background-color: #b82f2f;"></div>
                        <span class="legend-text">Interstate (INTER)</span>
                    </div>
                    <div class="war-type-item">
                        <div class="war-type-line" style="background-color: #2e7d32;"></div>
                        <span class="legend-text">Intrastate (INTRA)</span>
                    </div>
                </div>
            </div>

            <!-- Active Wars List -->
            <div class="legend" id="active-wars-legend" style="flex-direction: column; align-items: flex-start;">
                <span class="legend-title">Active Conflicts:</span>
                <div id="active-wars-list" style="font-size: 12px; text-align: left; max-height: 150px; overflow-y: auto; width: 100%;"></div>
            </div>
        </div>

        <!-- Proportional Symbol Map Section -->
        <div class="symbol-map-container">
            <h2>Global Conflict Sources by Country</h2>
            <p class="timeline-description">
                This proportional symbol map visualizes the total number of conflict data sources by country.
                Circle sizes are proportional to the total number of sources, with larger circles representing
                countries with more documented conflicts. Syria, Ukraine, and Afghanistan show the highest
                concentrations of conflict sources. Hover over circles to see exact source counts for each country.
            </p>
            
            <!-- Symbol Map Container -->
            <div class="map-container">
                <svg id="symbol-map" width="1000" height="500">
                    <!-- Legend will be positioned absolutely within this SVG -->
                </svg>
            </div>
        </div>
    </div>

    <!-- D3 Script -->
    <script>
        // Animation and data variables
        let isPlaying = false;
        let currentYear = 1989;
        let animationTimer = null;
        let deathsData = [];
        let worldData = null;
        let svg, projection, path, colorScale;
        
        // Comprehensive mapping: GeoJSON country name -> CSV country name
        const geoToCSVMap = {
            "United States of America": "United States of America",
            "Russia": "Russia (Soviet Union)", 
            "Russian Federation": "Russia (Soviet Union)",
            "Dem. Rep. Congo": "DR Congo (Zaire)",
            "Democratic Republic of the Congo": "DR Congo (Zaire)",
            "Myanmar": "Myanmar (Burma)",
            "Burma": "Myanmar (Burma)",
            "Yemen": "Yemen (North Yemen)",
            "Eswatini": "Kingdom of eSwatini (Swaziland)",
            "Swaziland": "Kingdom of eSwatini (Swaziland)",
            "Zimbabwe": "Zimbabwe (Rhodesia)",
            "Bosnia and Herzegovina": "Bosnia-Herzegovina",
            "Bosnia and Herz.": "Bosnia-Herzegovina",
            "Macedonia": "North Macedonia",
            "North Macedonia": "North Macedonia", 
            "Serbia": "Serbia (Yugoslavia)",
            "Cambodia": "Cambodia (Kampuchea)",
            "Madagascar": "Madagascar (Malagasy)",
            "Côte d'Ivoire": "Ivory Coast",
            "Turkey": "Turkey",
            "Türkiye": "Turkey",
            "Iran": "Iran",
            "Syria": "Syria",
            "Tanzania": "Tanzania",
            "Canada": "Canada",
            "Kazakhstan": "Kazakhstan",
            "Uzbekistan": "Uzbekistan", 
            "Argentina": "Argentina",
            "Chile": "Chile",
            "Fiji": "Fiji",
            "W. Sahara": "Morocco", // Western Sahara conflicts often coded as Morocco
            "Dominican Rep.": "Dominican Republic",
            "Eq. Guinea": "Equatorial Guinea",
            "Central African Rep.": "Central African Republic",
            "S. Sudan": "South Sudan",
            "Czech Rep.": "Czech Republic",
            "Slovak Rep.": "Slovakia",
            "Lao PDR": "Laos",
            "N. Korea": "North Korea",
            "S. Korea": "South Korea"
        };

        // Helper function to find alternative country name matches
        function findAlternativeCountryName(geoCountryName, dataMap) {
            // Try exact match first
            if (dataMap.has(geoCountryName)) {
                return geoCountryName;
            }
            
            // Try mapped conversion from GeoJSON name to CSV name
            if (geoToCSVMap[geoCountryName] && dataMap.has(geoToCSVMap[geoCountryName])) {
                return geoToCSVMap[geoCountryName];
            }
            
            // Try partial matching (contains)
            for (const [csvName, _] of dataMap.entries()) {
                if (geoCountryName.toLowerCase().includes(csvName.toLowerCase()) || 
                    csvName.toLowerCase().includes(geoCountryName.toLowerCase())) {
                    return csvName;
                }
            }
            
            return null;
        }

        // Initialize the map
        function initMap() {
            svg = d3.select("#world-map");
            const width = +svg.attr("width");
            const height = +svg.attr("height");

            // Set up projection and path
            projection = d3.geoNaturalEarth1()
                          .scale(160)
                          .translate([width / 2, height / 2]);
            
            path = d3.geoPath().projection(projection);

            // Add title
            svg.append("text")
               .attr("class", "map-title")
               .attr("x", width / 2)
               .attr("y", 25)
               .text("Global Conflict Deaths by Country");
        }

        // Load and process data
        async function loadData() {
            try {
                console.log("Loading data...");
                
                // Load deaths data
                deathsData = await d3.csv("deathsThroughYears.csv");
                console.log("Deaths data loaded:", deathsData.length, "rows");
                
                deathsData.forEach(d => {
                    d.year = +d.year;
                    d.deaths = +d.deaths;
                });

                // Try loading map data - handle both TopoJSON and GeoJSON
                let worldDataLoaded = false;
                const possibleFiles = ["world-110m.json", "world.geojson", "world-110m.geojson"];
                
                for (const filename of possibleFiles) {
                    try {
                        console.log("Trying to load:", filename);
                        const rawData = await d3.json(filename);
                        console.log("Successfully loaded:", filename);
                        console.log("Raw data structure:", rawData);
                        
                        // Check if it's TopoJSON or GeoJSON
                        if (rawData.type === "Topology") {
                            console.log("Converting TopoJSON to GeoJSON...");
                            // Convert TopoJSON to GeoJSON
                            // Try different possible object names
                            let objectName = null;
                            if (rawData.objects) {
                                const objectKeys = Object.keys(rawData.objects);
                                console.log("Available TopoJSON objects:", objectKeys);
                                
                                // Common object names in TopoJSON files
                                const commonNames = ["countries", "land", "world", "units", "collection"];
                                objectName = commonNames.find(name => objectKeys.includes(name)) || objectKeys[0];
                                console.log("Using object:", objectName);
                            }
                            
                            if (objectName && rawData.objects[objectName]) {
                                worldData = topojson.feature(rawData, rawData.objects[objectName]);
                                console.log("TopoJSON converted successfully");
                            } else {
                                throw new Error("Could not find valid object in TopoJSON");
                            }
                        } else if (rawData.type === "FeatureCollection") {
                            console.log("Using GeoJSON data directly");
                            worldData = rawData;
                        } else {
                            throw new Error("Unknown data format: " + rawData.type);
                        }
                        
                        worldDataLoaded = true;
                        break;
                    } catch (fileError) {
                        console.log("Failed to load:", filename, fileError.message);
                    }
                }
                
                if (!worldDataLoaded) {
                    throw new Error("Could not load world map data from any of the expected files");
                }
                
                // Validate the final world data structure
                if (!worldData || !worldData.features || !Array.isArray(worldData.features)) {
                    console.error("Invalid final data structure:", worldData);
                    throw new Error("Invalid map data format - missing features array");
                }
                
                console.log("Number of countries in map:", worldData.features.length);
                console.log("Sample country:", worldData.features[0]);
                console.log("Sample country properties:", worldData.features[0].properties);
                
                // Log all available property names from first few countries
                console.log("Available property names in countries:");
                worldData.features.slice(0, 5).forEach((feature, i) => {
                    console.log(`Country ${i} properties:`, Object.keys(feature.properties));
                });
                
                console.log("Data loaded successfully, drawing map...");
                drawMap();
                updateVisualization(currentYear);
                
            } catch (error) {
                console.error("Error loading data:", error);
                // Show error message to user
                d3.select("#world-map")
                  .append("text")
                  .attr("x", 500)
                  .attr("y", 200)
                  .attr("text-anchor", "middle")
                  .attr("fill", "#b82f2f")
                  .attr("font-size", "16px")
                  .attr("font-family", "'Fira Sans', sans-serif")
                  .text("Error loading map data:");
                  
                d3.select("#world-map")
                  .append("text")
                  .attr("x", 500)
                  .attr("y", 220)
                  .attr("text-anchor", "middle")
                  .attr("fill", "#666")
                  .attr("font-size", "14px")
                  .attr("font-family", "'Fira Sans', sans-serif")
                  .text(error.message);
                  
                d3.select("#world-map")
                  .append("text")
                  .attr("x", 500)
                  .attr("y", 250)
                  .attr("text-anchor", "middle")
                  .attr("fill", "#666")
                  .attr("font-size", "12px")
                  .attr("font-family", "'Fira Sans', sans-serif")
                  .text("Check browser console for details");
            }
        }

        // Draw the base map
        function drawMap() {
            if (!worldData || !worldData.features) {
                console.error("No world data available for drawing");
                return;
            }
            
            console.log("Drawing map with", worldData.features.length, "countries");
            
            svg.selectAll(".country")
               .data(worldData.features)
               .enter()
               .append("path")
               .attr("class", "country")
               .attr("d", path)
               .style("fill", "#ddd") // Ensure initial gray color
               .on("mouseover", function(event, d) {
                   showTooltip(event, d);
               })
               .on("mouseout", function() {
                   hideTooltip();
               });
               
            console.log("Map drawing completed");
        }

        // Get data for specific year
        function getYearData(year) {
            return deathsData.filter(d => d.year === year);
        }

        // Update visualization for specific year
        function updateVisualization(year) {
            const yearData = getYearData(year);
            console.log(`Updating visualization for year ${year}:`);
            console.log("Year data:", yearData.length, "countries with data");
            console.log("Sample year data:", yearData.slice(0, 5));
            
            // Create data map for easy lookup - use original country names as keys
            const dataMap = new Map();
            yearData.forEach(d => {
                dataMap.set(d.country, d.deaths);
            });

            console.log("Data map created with", dataMap.size, "countries");
            console.log("Sample data map entries:", Array.from(dataMap.entries()).slice(0, 5));

            // Update color scale based on current year data
            const deathValues = yearData.map(d => d.deaths);
            const maxDeaths = d3.max(deathValues) || 1;
            console.log("Max deaths for", year, ":", maxDeaths);
            
            // Use logarithmic scale for better color distribution across wide death ranges
            const minDeaths = d3.min(deathValues.filter(d => d > 0)) || 1;
            colorScale = d3.scaleSequential(d3.interpolateOrRd)
                          .domain([Math.log(minDeaths), Math.log(maxDeaths)]);

            // Update countries
            let matchedCountries = 0;
            let unmatchedCountries = [];
            let coloredCountries = 0;
            
            svg.selectAll(".country")
               .transition()
               .duration(300)
               .style("fill", d => {
                   const geoCountryName = d.properties.NAME || d.properties.ADMIN || d.properties.name || d.properties.NAME_EN || d.properties.SOVEREIGNT;
                   
                   // Removed excessive debugging for performance
                   
                   // Try direct match first
                   let deaths = dataMap.get(geoCountryName);
                   let matchedName = geoCountryName;
                   
                   if (deaths === undefined) {
                       // Try alternative matching
                       matchedName = findAlternativeCountryName(geoCountryName, dataMap);
                       deaths = matchedName ? dataMap.get(matchedName) : undefined;
                   }
                   
                   if (deaths !== undefined && deaths > 0) {
                       matchedCountries++;
                       coloredCountries++;
                       // Use logarithmic scaling for color mapping
                       const logDeaths = Math.log(Math.max(deaths, 1));
                       const color = colorScale(logDeaths);
                       if (year === 1989 && coloredCountries <= 3) {
                           console.log(`Coloring ${geoCountryName}: ${deaths} deaths -> ${color}`);
                       }
                       return color;
                   } else {
                       if (year === 1989) {
                           unmatchedCountries.push(geoCountryName);
                       }
                   }
                   return "#cccccc"; // Light gray for no data
               })
               .attr("class", d => {
                   const geoCountryName = d.properties.NAME || d.properties.ADMIN || d.properties.name || d.properties.NAME_EN || d.properties.SOVEREIGNT;
                   let deaths = dataMap.get(geoCountryName);
                   if (deaths === undefined) {
                       const matchedName = findAlternativeCountryName(geoCountryName, dataMap);
                       deaths = matchedName ? dataMap.get(matchedName) : undefined;
                   }
                   const hasData = deaths !== undefined && deaths > 0;
                   return hasData ? "country country-with-data" : "country";
               });
               
            console.log(`Year ${year}: Colored ${coloredCountries} countries`);

            // Update legend
            updateLegend(colorScale, maxDeaths);
            
            // Update current year display
            d3.select("#current-year").text(year);
            d3.select("#year-slider").property("value", year);
        }

        // Update legend
        function updateLegend(colorScale, maxValue) {
            const legend = d3.select("#legend");
            
            // Clear existing legend items
            legend.selectAll(".legend-item").remove();
            
            // Create legend items using logarithmic steps for better representation
            const steps = 6;
            const minValue = 1;
            const logMin = Math.log(minValue);
            const logMax = Math.log(maxValue);
            
            const legendData = d3.range(steps).map(i => {
                const logValue = logMin + (i / (steps - 1)) * (logMax - logMin);
                const value = Math.round(Math.exp(logValue));
                return {
                    value: value,
                    logValue: logValue,
                    color: colorScale(logValue)
                };
            });
            
            // Add "No data" item
            legendData.unshift({
                value: 0,
                logValue: 0,
                color: "#ddd"
            });

            const legendItems = legend.selectAll(".legend-item")
                                     .data(legendData)
                                     .enter()
                                     .append("div")
                                     .attr("class", "legend-item");

            legendItems.append("div")
                      .attr("class", "legend-color")
                      .style("background-color", d => d.color);

            legendItems.append("span")
                      .attr("class", "legend-text")
                      .text(d => d.value === 0 ? "No data" : d.value.toLocaleString());
        }

        // Tooltip functions
        function showTooltip(event, d) {
            const geoCountryName = d.properties.NAME || d.properties.ADMIN || d.properties.name || d.properties.NAME_EN || d.properties.SOVEREIGNT;
            const yearData = getYearData(currentYear);
            
            // Try to find matching country data
            const csvCountryName = findAlternativeCountryName(geoCountryName, new Map(yearData.map(item => [item.country, item.deaths])));
            const countryData = csvCountryName ? yearData.find(item => item.country === csvCountryName) : null;

            const deaths = countryData ? countryData.deaths.toLocaleString() : "No data";
            
            // Create or update tooltip
            let tooltip = d3.select("#tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body")
                           .append("div")
                           .attr("id", "tooltip")
                           .style("position", "absolute")
                           .style("background", "rgba(0,0,0,0.8)")
                           .style("color", "white")
                           .style("padding", "8px 12px")
                           .style("border-radius", "4px")
                           .style("font-size", "12px")
                           .style("font-family", "'Fira Sans', sans-serif")
                           .style("pointer-events", "none")
                           .style("opacity", 0);
            }
            
            tooltip.html(`<strong>${geoCountryName}</strong><br>Year: ${currentYear}<br>Deaths: ${deaths}`)
                   .style("left", (event.pageX + 10) + "px")
                   .style("top", (event.pageY - 10) + "px")
                   .transition()
                   .duration(200)
                   .style("opacity", 1);
        }

        function hideTooltip() {
            d3.select("#tooltip")
              .transition()
              .duration(200)
              .style("opacity", 0);
        }

        // Animation functions
        function toggleAnimation() {
            if (isPlaying) {
                pauseAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            if (isPlaying) return;
            
            isPlaying = true;
            updatePlayPauseButton();
            
            animationTimer = setInterval(() => {
                currentYear++;
                if (currentYear > 2024) {
                    currentYear = 1989; // Loop back to start
                }
                updateVisualization(currentYear);
            }, 800); // 800ms per year as specified
        }

        function pauseAnimation() {
            if (!isPlaying) return;
            
            isPlaying = false;
            clearInterval(animationTimer);
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const button = d3.select("#play-pause-btn");
            if (isPlaying) {
                button.text("⏸ Pause")
                      .classed("playing", true);
            } else {
                button.text("▶ Play")
                      .classed("playing", false);
            }
        }

        // Event listeners
        function setupEventListeners() {
            d3.select("#play-pause-btn").on("click", toggleAnimation);
            
            d3.select("#year-slider").on("input", function() {
                const year = +this.value;
                currentYear = year;
                updateVisualization(year);
                
                // Pause animation if it's playing
                if (isPlaying) {
                    pauseAnimation();
                }
            });
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Page loaded, initializing timeline...");
            console.log("D3 version:", d3.version);
            
            initMap();
            setupEventListeners();
            loadData();
            
            // Initialize connection map
            initConnectionMap();
            
            console.log("Initialization complete");
        });

        // ==================== CONNECTION MAP CODE ====================
        
        let connectionSvg, connectionProjection, connectionPath;
        let warData = [];
        let connectionWorldData = null;
        let showAllWars = false;
        let connectionCurrentYear = 1990;
        
        // Country name mapping for matching CSV to GeoJSON
        const countryNameMap = {
            "United States of America": ["United States of America", "United States", "USA"],
            "Russia (Soviet Union)": ["Russia", "Russian Federation", "USSR", "Soviet Union"],
            "United Kingdom": ["United Kingdom", "Great Britain", "UK", "Britain"],
            "DR Congo (Zaire)": ["Dem. Rep. Congo", "Democratic Republic of the Congo", "DRC", "Zaire"],
            "Myanmar (Burma)": ["Myanmar", "Burma"],
            "Yugoslavia": ["Serbia", "Yugoslavia", "Kosovo"],
            "Yugoslavia (Kingdom of Serbia)": ["Serbia", "Yugoslavia"],
            "Germany": ["Germany", "West Germany", "East Germany"],
            "Vietnam": ["Vietnam", "Viet Nam"],
            "Republic of Vietnam": ["Vietnam", "South Vietnam"],
            "Korea": ["South Korea", "North Korea", "Korea"],
            "South Korea": ["South Korea", "Korea, Republic of"],
            "North Korea": ["North Korea", "Korea, Dem. People's Rep."],
            "Yemen Arab Republic": ["Yemen", "North Yemen"],
            "Yemen People's Republic": ["Yemen", "South Yemen"],
            "Czechoslovakia": ["Czech Republic", "Slovakia", "Czechia"],
            "Austria-Hungary": ["Austria", "Hungary"],
            "Two Sicilies": ["Italy"],
            "Papal States": ["Italy", "Vatican"],
            "Ottoman Empire": ["Turkey"],
            "Egypt": ["Egypt"],
            "China": ["China"],
            "Tibet": ["China"],
            "Taiwan": ["Taiwan"],
            "Iran": ["Iran"],
            "Iraq": ["Iraq"],
            "Saudi Arabia": ["Saudi Arabia"],
            "Ethiopia": ["Ethiopia"],
            "Eritrea": ["Eritrea"],
            "Sudan": ["Sudan", "South Sudan"],
            "South Africa": ["South Africa"],
            "Bosnia and Herzegovina": ["Bosnia and Herzegovina", "Bosnia and Herz."],
            "Bosnia-Herzegovina": ["Bosnia and Herzegovina", "Bosnia and Herz."],
            "Croatia": ["Croatia"],
            "Macedonia": ["North Macedonia", "Macedonia"],
            "Belgium": ["Belgium"],
            "Netherlands": ["Netherlands"],
            "France": ["France"],
            "Spain": ["Spain"],
            "Portugal": ["Portugal"],
            "Italy": ["Italy"],
            "Greece": ["Greece"],
            "Poland": ["Poland"],
            "Hungary": ["Hungary"],
            "Romania": ["Romania", "Rumania"],
            "Bulgaria": ["Bulgaria"],
            "Finland": ["Finland"],
            "Norway": ["Norway"],
            "Sweden": ["Sweden"],
            "Denmark": ["Denmark"],
            "Turkey": ["Turkey", "Türkiye"],
            "Syria": ["Syria"],
            "Lebanon": ["Lebanon"],
            "Jordan": ["Jordan"],
            "Israel": ["Israel"],
            "Cyprus": ["Cyprus"],
            "Afghanistan": ["Afghanistan"],
            "Pakistan": ["Pakistan"],
            "India": ["India"],
            "Bangladesh": ["Bangladesh"],
            "Sri Lanka": ["Sri Lanka"],
            "Nepal": ["Nepal"],
            "Bhutan": ["Bhutan"],
            "Thailand": ["Thailand"],
            "Cambodia": ["Cambodia"],
            "Laos": ["Laos", "Lao PDR"],
            "Malaysia": ["Malaysia"],
            "Indonesia": ["Indonesia"],
            "Philippines": ["Philippines"],
            "Japan": ["Japan"],
            "Mongolia": ["Mongolia"],
            "Australia": ["Australia"],
            "New Zealand": ["New Zealand"],
            "Canada": ["Canada"],
            "Mexico": ["Mexico"],
            "Cuba": ["Cuba"],
            "Haiti": ["Haiti"],
            "Dominican Republic": ["Dominican Republic", "Dominican Rep."],
            "Guatemala": ["Guatemala"],
            "El Salvador": ["El Salvador"],
            "Honduras": ["Honduras"],
            "Nicaragua": ["Nicaragua"],
            "Costa Rica": ["Costa Rica"],
            "Panama": ["Panama"],
            "Colombia": ["Colombia"],
            "Venezuela": ["Venezuela"],
            "Ecuador": ["Ecuador"],
            "Peru": ["Peru"],
            "Bolivia": ["Bolivia"],
            "Chile": ["Chile"],
            "Argentina": ["Argentina"],
            "Uruguay": ["Uruguay"],
            "Paraguay": ["Paraguay"],
            "Brazil": ["Brazil"],
            "Algeria": ["Algeria"],
            "Morocco": ["Morocco"],
            "Tunisia": ["Tunisia"],
            "Libya": ["Libya"],
            "Nigeria": ["Nigeria"],
            "Ghana": ["Ghana"],
            "Ivory Coast": ["Côte d'Ivoire", "Ivory Coast"],
            "Senegal": ["Senegal"],
            "Mali": ["Mali"],
            "Guinea": ["Guinea"],
            "Guinea-Bissau": ["Guinea-Bissau"],
            "Sierra Leone": ["Sierra Leone"],
            "Liberia": ["Liberia"],
            "Cameroon": ["Cameroon"],
            "Chad": ["Chad"],
            "Central African Republic": ["Central African Republic", "Central African Rep."],
            "Congo": ["Congo", "Republic of the Congo"],
            "Democratic Republic of the Congo": ["Dem. Rep. Congo", "Democratic Republic of the Congo", "DRC"],
            "Angola": ["Angola"],
            "Namibia": ["Namibia"],
            "Zambia": ["Zambia"],
            "Zimbabwe": ["Zimbabwe"],
            "Mozambique": ["Mozambique"],
            "Madagascar": ["Madagascar"],
            "Tanzania": ["Tanzania"],
            "Kenya": ["Kenya"],
            "Uganda": ["Uganda"],
            "Rwanda": ["Rwanda"],
            "Burundi": ["Burundi"],
            "Somalia": ["Somalia"],
            "Djibouti": ["Djibouti"],
            "Kuwait": ["Kuwait"],
            "Qatar": ["Qatar"],
            "United Arab Emirates": ["United Arab Emirates", "UAE"],
            "Oman": ["Oman"],
            "Armenia": ["Armenia"],
            "Azerbaijan": ["Azerbaijan"],
            "Georgia": ["Georgia"],
            "Ukraine": ["Ukraine"],
            "Belarus": ["Belarus"],
            "Lithuania": ["Lithuania"],
            "Latvia": ["Latvia"],
            "Estonia": ["Estonia"],
            "Kazakhstan": ["Kazakhstan"],
            "Uzbekistan": ["Uzbekistan"],
            "Turkmenistan": ["Turkmenistan"],
            "Tajikistan": ["Tajikistan"],
            "Kyrgyzstan": ["Kyrgyzstan", "Kyrgystan"]
        };

        // War type colors
        const warTypeColors = {
            "INTER": "#b82f2f",  // Red for interstate wars
            "INTRA": "#2e7d32"   // Green for intrastate wars
        };

        function initConnectionMap() {
            connectionSvg = d3.select("#connection-map");
            const width = +connectionSvg.attr("width");
            const height = +connectionSvg.attr("height");

            // Set up projection and path
            connectionProjection = d3.geoNaturalEarth1()
                          .scale(160)
                          .translate([width / 2, height / 2]);
            
            connectionPath = d3.geoPath().projection(connectionProjection);

            // Add title
            connectionSvg.append("text")
               .attr("class", "map-title")
               .attr("x", width / 2)
               .attr("y", 25)
               .text("War Connections Between Countries");

            // Add group for countries (drawn first, so it's behind)
            connectionSvg.append("g").attr("id", "countries-group");
            
            // Add group for connections (drawn after countries, so it's on top)
            connectionSvg.append("g").attr("id", "connections-group");

            // Load data
            loadConnectionMapData();
            setupConnectionMapListeners();
        }

        async function loadConnectionMapData() {
            try {
                console.log("Loading connection map data...");
                
                // Load war data
                const rawWarData = await d3.csv("WarList.csv");
                console.log("War data loaded:", rawWarData.length, "rows");
                
                // Process war data - filter out empty rows
                warData = rawWarData.filter(d => d["War Name"] && d["Time Span"] && d["State Participants"]).map(d => {
                    const timeSpan = d["Time Span"];
                    const years = timeSpan.split("-");
                    const startYear = parseInt(years[0]);
                    const endYear = years[1] ? parseInt(years[1]) : startYear;
                    
                    // Parse participants - split by comma and clean up
                    const participants = d["State Participants"]
                        .split(",")
                        .map(p => p.trim())
                        .filter(p => p.length > 0);
                    
                    return {
                        mainType: d["Main type"],
                        warName: d["War Name"],
                        timeSpan: timeSpan,
                        startYear: startYear,
                        endYear: endYear,
                        locations: d["Locations"],
                        participants: participants
                    };
                });
                
                console.log("Processed war data:", warData.length, "wars");
                console.log("Sample war:", warData[0]);

                // Reuse world data if already loaded, otherwise load it
                if (!worldData) {
                    const possibleFiles = ["world-110m.json", "world.geojson", "world-110m.geojson"];
                    
                    for (const filename of possibleFiles) {
                        try {
                            console.log("Trying to load:", filename);
                            const rawData = await d3.json(filename);
                            
                            if (rawData.type === "Topology") {
                                let objectName = null;
                                if (rawData.objects) {
                                    const objectKeys = Object.keys(rawData.objects);
                                    const commonNames = ["countries", "land", "world", "units", "collection"];
                                    objectName = commonNames.find(name => objectKeys.includes(name)) || objectKeys[0];
                                }
                                
                                if (objectName && rawData.objects[objectName]) {
                                    connectionWorldData = topojson.feature(rawData, rawData.objects[objectName]);
                                }
                            } else if (rawData.type === "FeatureCollection") {
                                connectionWorldData = rawData;
                            }
                            break;
                        } catch (fileError) {
                            console.log("Failed to load:", filename);
                        }
                    }
                } else {
                    connectionWorldData = worldData;
                }

                if (connectionWorldData) {
                    drawConnectionMap();
                    updateConnectionMap(connectionCurrentYear);
                }
                
            } catch (error) {
                console.error("Error loading connection map data:", error);
            }
        }

        function drawConnectionMap() {
            if (!connectionWorldData || !connectionWorldData.features) {
                console.error("No world data available for connection map");
                return;
            }
            
            console.log("Drawing connection map with", connectionWorldData.features.length, "countries");
            
            connectionSvg.select("#countries-group")
               .selectAll(".country-node")
               .data(connectionWorldData.features)
               .enter()
               .append("path")
               .attr("class", "country-node")
               .attr("d", connectionPath)
               .style("fill", "#e0e0e0")
               .style("stroke", "#fff")
               .style("stroke-width", "0.5px")
               .on("mouseover", function(event, d) {
                   showCountryTooltip(event, d);
                   d3.select(this)
                       .style("stroke", "#333")
                       .style("stroke-width", "2px");
               })
               .on("mousemove", function(event) {
                   moveCountryTooltip(event);
               })
               .on("mouseout", function() {
                   hideCountryTooltip();
                   d3.select(this)
                       .style("stroke", "#fff")
                       .style("stroke-width", "0.5px");
               });
               
            console.log("Connection map base drawn");
        }

        function getCountryCentroid(countryName) {
            if (!connectionWorldData || !connectionWorldData.features) return null;
            
            // Find matching country in GeoJSON
            for (const feature of connectionWorldData.features) {
                const geoName = feature.properties.NAME || feature.properties.ADMIN || feature.properties.name || feature.properties.NAME_EN;
                
                // Check if this geo country matches the war participant
                const mappedNames = countryNameMap[countryName];
                if (mappedNames) {
                    for (const mappedName of mappedNames) {
                        if (geoName && (geoName === mappedName || 
                            geoName.toLowerCase().includes(mappedName.toLowerCase()) ||
                            mappedName.toLowerCase().includes(geoName.toLowerCase()))) {
                            const centroid = connectionPath.centroid(feature);
                            if (!isNaN(centroid[0]) && !isNaN(centroid[1])) {
                                return centroid;
                            }
                        }
                    }
                }
                
                // Direct name match
                if (geoName && (geoName === countryName || 
                    geoName.toLowerCase().includes(countryName.toLowerCase()) ||
                    countryName.toLowerCase().includes(geoName.toLowerCase()))) {
                    const centroid = connectionPath.centroid(feature);
                    if (!isNaN(centroid[0]) && !isNaN(centroid[1])) {
                        return centroid;
                    }
                }
            }
            
            return null;
        }

        function getActiveWars(year) {
            if (showAllWars) {
                return warData;
            }
            return warData.filter(war => war.startYear <= year && war.endYear >= year);
        }

        function updateConnectionMap(year) {
            connectionCurrentYear = year;
            const activeWars = getActiveWars(year);
            
            console.log(`Active wars in ${year}:`, activeWars.length);
            
            // Clear existing connections
            connectionSvg.select("#connections-group").selectAll("*").remove();
            
            // Reset country colors
            connectionSvg.select("#countries-group")
                .selectAll(".country-node")
                .style("fill", "#e0e0e0");
            
            // Track countries involved in wars
            const involvedCountries = new Set();
            const connections = [];
            
            // Process each active war
            activeWars.forEach(war => {
                const participants = war.participants;
                
                if (participants.length >= 2) {
                    // Create connections between all pairs of participants
                    for (let i = 0; i < participants.length; i++) {
                        for (let j = i + 1; j < participants.length; j++) {
                            const country1 = participants[i];
                            const country2 = participants[j];
                            
                            const centroid1 = getCountryCentroid(country1);
                            const centroid2 = getCountryCentroid(country2);
                            
                            if (centroid1 && centroid2) {
                                connections.push({
                                    source: centroid1,
                                    target: centroid2,
                                    war: war,
                                    country1: country1,
                                    country2: country2
                                });
                                involvedCountries.add(country1);
                                involvedCountries.add(country2);
                            }
                        }
                    }
                } else if (participants.length === 1) {
                    // Single participant (internal conflict) - just highlight the country
                    involvedCountries.add(participants[0]);
                }
            });
            
            // Draw curved connection lines
            const lineGenerator = d3.line()
                .x(d => d[0])
                .y(d => d[1])
                .curve(d3.curveBasis);
            
            connectionSvg.select("#connections-group")
                .selectAll(".connection-line")
                .data(connections)
                .enter()
                .append("path")
                .attr("class", "connection-line")
                .attr("d", d => {
                    // Create curved path with control point
                    const midX = (d.source[0] + d.target[0]) / 2;
                    const midY = (d.source[1] + d.target[1]) / 2;
                    const dx = d.target[0] - d.source[0];
                    const dy = d.target[1] - d.source[1];
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Curve height proportional to distance
                    const curveHeight = Math.min(dist * 0.2, 50);
                    const controlX = midX - (dy / dist) * curveHeight;
                    const controlY = midY + (dx / dist) * curveHeight;
                    
                    return lineGenerator([d.source, [controlX, controlY], d.target]);
                })
                .style("stroke", d => warTypeColors[d.war.mainType] || "#666")
                .style("stroke-width", 2)
                .on("mouseover", function(event, d) {
                    showConnectionTooltip(event, d);
                    d3.select(this)
                        .style("stroke-width", 4)
                        .style("stroke-opacity", 1);
                })
                .on("mousemove", function(event, d) {
                    moveConnectionTooltip(event);
                })
                .on("mouseout", function() {
                    hideConnectionTooltip();
                    d3.select(this)
                        .style("stroke-width", 2)
                        .style("stroke-opacity", 0.6);
                });
            
            // Highlight involved countries
            connectionSvg.select("#countries-group")
                .selectAll(".country-node")
                .style("fill", function(d) {
                    const geoName = d.properties.NAME || d.properties.ADMIN || d.properties.name || d.properties.NAME_EN;
                    
                    for (const country of involvedCountries) {
                        const mappedNames = countryNameMap[country];
                        if (mappedNames) {
                            for (const mappedName of mappedNames) {
                                if (geoName && (geoName === mappedName || 
                                    geoName.toLowerCase().includes(mappedName.toLowerCase()) ||
                                    mappedName.toLowerCase().includes(geoName.toLowerCase()))) {
                                    return "#ffcc80";  // Orange highlight for involved countries
                                }
                            }
                        }
                        
                        if (geoName && (geoName === country || 
                            geoName.toLowerCase().includes(country.toLowerCase()) ||
                            country.toLowerCase().includes(geoName.toLowerCase()))) {
                            return "#ffcc80";
                        }
                    }
                    
                    return "#e0e0e0";
                });
            
            // Update active wars list
            updateActiveWarsList(activeWars);
            
            // Update year display
            d3.select("#connection-current-year").text(showAllWars ? "All" : year);
        }

        function updateActiveWarsList(activeWars) {
            const listContainer = d3.select("#active-wars-list");
            listContainer.html("");
            
            if (activeWars.length === 0) {
                listContainer.html("<em>No active conflicts in this year</em>");
                return;
            }
            
            // Limit display if showing all wars
            const displayWars = showAllWars ? activeWars.slice(0, 50) : activeWars;
            
            displayWars.forEach(war => {
                const warItem = listContainer.append("div")
                    .style("margin", "5px 0")
                    .style("padding", "5px")
                    .style("background", "#f9f9f9")
                    .style("border-radius", "4px")
                    .style("border-left", `3px solid ${warTypeColors[war.mainType] || "#666"}`);
                
                warItem.append("strong")
                    .style("color", warTypeColors[war.mainType] || "#333")
                    .text(war.warName);
                
                warItem.append("span")
                    .style("color", "#666")
                    .style("margin-left", "10px")
                    .text(`(${war.timeSpan}) - ${war.participants.join(", ")}`);
            });
            
            if (showAllWars && activeWars.length > 50) {
                listContainer.append("div")
                    .style("margin-top", "10px")
                    .style("font-style", "italic")
                    .style("color", "#666")
                    .text(`...and ${activeWars.length - 50} more conflicts`);
            }
        }

        function showConnectionTooltip(event, d) {
            let tooltip = d3.select("#connection-tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body")
                    .append("div")
                    .attr("id", "connection-tooltip")
                    .attr("class", "connection-tooltip")
                    .style("opacity", 0);
            }
            
            tooltip.html(`
                <div class="war-name">${d.war.warName}</div>
                <div class="war-details">
                    <strong>Type:</strong> ${d.war.mainType === "INTER" ? "Interstate" : "Intrastate"}<br>
                    <strong>Period:</strong> ${d.war.timeSpan}<br>
                    <strong>Location:</strong> ${d.war.locations}<br>
                    <strong>Participants:</strong> ${d.war.participants.join(", ")}<br>
                    <strong>Connection:</strong> ${d.country1} ↔ ${d.country2}
                </div>
            `)
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 10) + "px")
            .transition()
            .duration(200)
            .style("opacity", 1);
        }

        function moveConnectionTooltip(event) {
            d3.select("#connection-tooltip")
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideConnectionTooltip() {
            d3.select("#connection-tooltip")
                .transition()
                .duration(200)
                .style("opacity", 0);
        }

        function showCountryTooltip(event, d) {
            const countryName = d.properties.NAME || d.properties.ADMIN || d.properties.name || d.properties.NAME_EN || "Unknown";
            
            // Find wars involving this country
            const activeWars = getActiveWars(connectionCurrentYear);
            const countryWars = activeWars.filter(war => {
                return war.participants.some(participant => {
                    const mappedNames = countryNameMap[participant];
                    if (mappedNames) {
                        return mappedNames.some(name => 
                            countryName.toLowerCase().includes(name.toLowerCase()) ||
                            name.toLowerCase().includes(countryName.toLowerCase())
                        );
                    }
                    return countryName.toLowerCase().includes(participant.toLowerCase()) ||
                           participant.toLowerCase().includes(countryName.toLowerCase());
                });
            });
            
            let tooltip = d3.select("#country-tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body")
                    .append("div")
                    .attr("id", "country-tooltip")
                    .attr("class", "connection-tooltip")
                    .style("opacity", 0);
            }
            
            let warsHtml = "";
            if (countryWars.length > 0) {
                warsHtml = `<br><strong>Active Conflicts (${countryWars.length}):</strong><br>`;
                countryWars.slice(0, 5).forEach(war => {
                    warsHtml += `• ${war.warName} (${war.timeSpan})<br>`;
                });
                if (countryWars.length > 5) {
                    warsHtml += `<em>...and ${countryWars.length - 5} more</em>`;
                }
            } else {
                warsHtml = `<br><em>No active conflicts in ${showAllWars ? "dataset" : connectionCurrentYear}</em>`;
            }
            
            tooltip.html(`
                <div class="war-name">${countryName}</div>
                <div class="war-details">
                    ${warsHtml}
                </div>
            `)
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 10) + "px")
            .transition()
            .duration(200)
            .style("opacity", 1);
        }

        function moveCountryTooltip(event) {
            d3.select("#country-tooltip")
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideCountryTooltip() {
            d3.select("#country-tooltip")
                .transition()
                .duration(200)
                .style("opacity", 0);
        }

        function setupConnectionMapListeners() {
            d3.select("#connection-year-slider").on("input", function() {
                const year = +this.value;
                showAllWars = false;
                d3.select("#show-all-wars-btn").text("Show All Wars");
                updateConnectionMap(year);
            });
            
            d3.select("#show-all-wars-btn").on("click", function() {
                showAllWars = !showAllWars;
                if (showAllWars) {
                    d3.select(this).text("Filter by Year");
                    updateConnectionMap(connectionCurrentYear);
                } else {
                    d3.select(this).text("Show All Wars");
                    updateConnectionMap(+d3.select("#connection-year-slider").property("value"));
                }
            });
        }
    </script>
    
    <script>
        // ==================== PROPORTIONAL SYMBOL MAP CODE ====================
        
        let symbolSvg, symbolProjection, symbolPath;
        let countrySourcesData = [];
        let symbolWorldData = null;
        let radiusScale;
        
        // Enhanced country name mapping for sources data
        const sourceCountryNameMap = {
            // Exact matches from CSV
            "Syria": ["Syria"],
            "Ukraine": ["Ukraine"],
            "Afghanistan": ["Afghanistan"],
            "Mexico": ["Mexico"],
            "Bosnia-Herzegovina": ["Bosnia and Herzegovina", "Bosnia and Herz."],
            "India": ["India"],
            "DR Congo (Zaire)": ["Dem. Rep. Congo", "Democratic Republic of the Congo", "Congo, Dem. Rep."],
            "Colombia": ["Colombia"],
            "Nigeria": ["Nigeria"],
            "Brazil": ["Brazil"],
            "Israel": ["Israel"],
            "Myanmar (Burma)": ["Myanmar", "Burma"],
            "Somalia": ["Somalia"],
            "Iraq": ["Iraq"],
            "Yemen (North Yemen)": ["Yemen"],
            "Ethiopia": ["Ethiopia"],
            "Pakistan": ["Pakistan"],
            "Mali": ["Mali"],
            "Sudan": ["Sudan"],
            "Turkey": ["Turkey", "Türkiye"],
            "Burundi": ["Burundi"],
            "Burkina Faso": ["Burkina Faso"],
            "Cameroon": ["Cameroon"],
            "Central African Republic": ["Central African Republic", "Central African Rep."],
            "Rwanda": ["Rwanda"],
            "Philippines": ["Philippines"],
            "Lebanon": ["Lebanon"],
            "Russia (Soviet Union)": ["Russia", "Russian Federation"],
            "Mozambique": ["Mozambique"],
            "Libya": ["Libya"],
            "Kenya": ["Kenya"],
            "Venezuela": ["Venezuela"],
            "South Sudan": ["South Sudan", "S. Sudan"],
            "Egypt": ["Egypt"],
            "Niger": ["Niger"],
            "Indonesia": ["Indonesia"],
            "Azerbaijan": ["Azerbaijan"],
            "Ecuador": ["Ecuador"],
            "Thailand": ["Thailand"],
            "Iran": ["Iran"],
            "Serbia (Yugoslavia)": ["Serbia"],
            "Haiti": ["Haiti"],
            "Algeria": ["Algeria"],
            "Sierra Leone": ["Sierra Leone"],
            "Chad": ["Chad"],
            "El Salvador": ["El Salvador"],
            "Bangladesh": ["Bangladesh"],
            "Trinidad and Tobago": ["Trinidad and Tobago"],
            "Angola": ["Angola"],
            "Tunisia": ["Tunisia"],
            "Peru": ["Peru"],
            "United Kingdom": ["United Kingdom"],
            "Guatemala": ["Guatemala"],
            "Spain": ["Spain"],
            "Papua New Guinea": ["Papua New Guinea"],
            "Uganda": ["Uganda"],
            "Ivory Coast": ["Côte d'Ivoire", "Ivory Coast"],
            "South Africa": ["South Africa"],
            "Armenia": ["Armenia"],
            "Benin": ["Benin"],
            "Saudi Arabia": ["Saudi Arabia"],
            "Tajikistan": ["Tajikistan"],
            "France": ["France"],
            "Togo": ["Togo"],
            "Honduras": ["Honduras"],
            "Kyrgyzstan": ["Kyrgyzstan"],
            "Cambodia (Kampuchea)": ["Cambodia"],
            "Tanzania": ["Tanzania"],
            "Congo": ["Congo", "Republic of the Congo"],
            "Sri Lanka": ["Sri Lanka"],
            "Kingdom of eSwatini (Swaziland)": ["Eswatini", "Swaziland"],
            "Nicaragua": ["Nicaragua"],
            "Zambia": ["Zambia"],
            "Canada": ["Canada"],
            "Senegal": ["Senegal"],
            "Jamaica": ["Jamaica"],
            "Madagascar (Malagasy)": ["Madagascar"],
            "Ghana": ["Ghana"],
            "Morocco": ["Morocco"],
            "Zimbabwe (Rhodesia)": ["Zimbabwe"],
            "Mauritania": ["Mauritania"],
            "Guinea": ["Guinea"],
            "Panama": ["Panama"],
            "United States of America": ["United States of America", "United States"],
            "Belgium": ["Belgium"],
            "Djibouti": ["Djibouti"],
            "Jordan": ["Jordan"],
            "Nepal": ["Nepal"],
            "Bolivia": ["Bolivia"],
            "Paraguay": ["Paraguay"],
            "Eritrea": ["Eritrea"],
            "Namibia": ["Namibia"],
            "China": ["China"],
            "Gambia": ["Gambia"],
            "Sweden": ["Sweden"],
            "Germany": ["Germany"],
            "Kuwait": ["Kuwait"],
            "Liberia": ["Liberia"],
            "Australia": ["Australia"],
            "Georgia": ["Georgia"],
            "Argentina": ["Argentina"],
            "Lesotho": ["Lesotho"],
            "Malaysia": ["Malaysia"],
            "Comoros": ["Comoros"],
            "United Arab Emirates": ["United Arab Emirates", "UAE"],
            "Netherlands": ["Netherlands"],
            "Guyana": ["Guyana"],
            "Uzbekistan": ["Uzbekistan"],
            "Austria": ["Austria"],
            "Croatia": ["Croatia"],
            "Solomon Islands": ["Solomon Islands"],
            "Poland": ["Poland"]
        };
        
        function initSymbolMap() {
            symbolSvg = d3.select("#symbol-map");
            const width = +symbolSvg.attr("width");
            const height = +symbolSvg.attr("height");

            // Set up projection and path - same as other maps for consistency
            symbolProjection = d3.geoNaturalEarth1()
                          .scale(160)
                          .translate([width / 2, height / 2]);
            
            symbolPath = d3.geoPath().projection(symbolProjection);

            // Add title
            symbolSvg.append("text")
               .attr("class", "map-title")
               .attr("x", width / 2)
               .attr("y", 25)
               .text("Conflict Data Sources by Country");

            // Add group for basemap (drawn first)
            symbolSvg.append("g").attr("id", "basemap-group");
            
            // Add group for symbols (drawn on top)
            symbolSvg.append("g").attr("id", "symbols-group");

            // Load data
            loadSymbolMapData();
        }

        async function loadSymbolMapData() {
            try {
                console.log("Loading symbol map data...");
                
                // Load country sources data
                countrySourcesData = await d3.csv("country_sources.csv");
                console.log("Country sources data loaded:", countrySourcesData.length, "rows");
                
                // Process data
                countrySourcesData.forEach(d => {
                    d.total_sources = +d.total_sources;
                });
                
                console.log("Sample sources data:", countrySourcesData.slice(0, 5));

                // Reuse world data if already loaded
                if (!worldData) {
                    const possibleFiles = ["world-110m.json", "world.geojson", "world-110m.geojson"];
                    
                    for (const filename of possibleFiles) {
                        try {
                            console.log("Trying to load:", filename);
                            const rawData = await d3.json(filename);
                            
                            if (rawData.type === "Topology") {
                                let objectName = null;
                                if (rawData.objects) {
                                    const objectKeys = Object.keys(rawData.objects);
                                    const commonNames = ["countries", "land", "world", "units", "collection"];
                                    objectName = commonNames.find(name => objectKeys.includes(name)) || objectKeys[0];
                                }
                                
                                if (objectName && rawData.objects[objectName]) {
                                    symbolWorldData = topojson.feature(rawData, rawData.objects[objectName]);
                                }
                            } else if (rawData.type === "FeatureCollection") {
                                symbolWorldData = rawData;
                            }
                            break;
                        } catch (fileError) {
                            console.log("Failed to load:", filename);
                        }
                    }
                } else {
                    symbolWorldData = worldData;
                }

                if (symbolWorldData) {
                    drawSymbolMap();
                }
                
            } catch (error) {
                console.error("Error loading symbol map data:", error);
            }
        }

        function drawSymbolMap() {
            if (!symbolWorldData || !symbolWorldData.features) {
                console.error("No world data available for symbol map");
                return;
            }
            
            console.log("Drawing symbol map with", symbolWorldData.features.length, "countries");
            
            // Draw basemap
            symbolSvg.select("#basemap-group")
               .selectAll(".basemap-country")
               .data(symbolWorldData.features)
               .enter()
               .append("path")
               .attr("class", "basemap-country")
               .attr("d", symbolPath)
               .on("mouseover", function(event, d) {
                   const geoCountryName = d.properties.NAME || d.properties.ADMIN || d.properties.name || d.properties.NAME_EN || d.properties.SOVEREIGNT;
                   
                   // Find matching sources data
                   let sources = null;
                   let matchedName = geoCountryName;
                   
                   // Check if this country has sources data
                   const sourcesMap = new Map();
                   countrySourcesData.forEach(data => {
                       sourcesMap.set(data.country, data.total_sources);
                   });
                   
                   sources = sourcesMap.get(geoCountryName);
                   
                   if (sources === undefined) {
                       // Try alternative matching using our mapping
                       for (const [csvName, geoNames] of Object.entries(sourceCountryNameMap)) {
                           if (geoNames.some(geoName => 
                               geoName === geoCountryName || 
                               geoCountryName.toLowerCase().includes(geoName.toLowerCase()) ||
                               geoName.toLowerCase().includes(geoCountryName.toLowerCase())
                           )) {
                               sources = sourcesMap.get(csvName);
                               matchedName = csvName;
                               break;
                           }
                       }
                   }
                   
                   // Only show tooltip if country has data
                   if (sources !== undefined && sources > 0) {
                       showSymbolTooltip(event, {
                           country: geoCountryName,
                           csvName: matchedName,
                           sources: sources
                       });
                       
                       // Highlight the corresponding circle
                       symbolSvg.selectAll(".source-circle")
                           .filter(circleData => circleData.country === geoCountryName || circleData.csvName === matchedName)
                           .style("fill-opacity", 0.9)
                           .style("stroke-width", "2px")
                           .attr("r", function() { 
                               const currentRadius = +d3.select(this).attr("r");
                               d3.select(this).attr("data-original-radius", currentRadius);
                               return currentRadius * 1.1; 
                           });
                           
                       // Dim other circles
                       symbolSvg.selectAll(".source-circle")
                           .filter(circleData => circleData.country !== geoCountryName && circleData.csvName !== matchedName)
                           .style("fill-opacity", 0.3);
                   }
               })
               .on("mouseout", function(event, d) {
                   hideSymbolTooltip();
                   
                   // Reset all circles
                   symbolSvg.selectAll(".source-circle")
                       .style("fill-opacity", 0.7)
                       .style("stroke-width", "1px")
                       .attr("r", function() { 
                           const originalRadius = +d3.select(this).attr("data-original-radius");
                           return originalRadius || +d3.select(this).attr("r") / 1.1;
                       });
               });
            
            // Create radius scale
            const sourceValues = countrySourcesData.map(d => d.total_sources);
            const maxSources = d3.max(sourceValues);
            const minSources = d3.min(sourceValues.filter(d => d > 0));
            
            // Use square root scale for circle areas
            radiusScale = d3.scaleSqrt()
                          .domain([0, maxSources])
                          .range([0, 25]); // 0 to 25 pixels radius
            
            console.log("Radius scale domain:", [0, maxSources]);
            console.log("Radius scale range:", [0, 25]);
            
            // Create data map for easy lookup
            const sourcesMap = new Map();
            countrySourcesData.forEach(d => {
                sourcesMap.set(d.country, d.total_sources);
            });
            
            // Prepare symbol data by matching countries
            const symbolData = [];
            let matchedCount = 0;
            
            symbolWorldData.features.forEach(feature => {
                const geoCountryName = feature.properties.NAME || feature.properties.ADMIN || feature.properties.name || feature.properties.NAME_EN || feature.properties.SOVEREIGNT;
                
                // Try to find matching sources data
                let sources = sourcesMap.get(geoCountryName);
                let matchedName = geoCountryName;
                
                if (sources === undefined) {
                    // Try alternative matching using our mapping
                    for (const [csvName, geoNames] of Object.entries(sourceCountryNameMap)) {
                        if (geoNames.some(geoName => 
                            geoName === geoCountryName || 
                            geoCountryName.toLowerCase().includes(geoName.toLowerCase()) ||
                            geoName.toLowerCase().includes(geoCountryName.toLowerCase())
                        )) {
                            sources = sourcesMap.get(csvName);
                            matchedName = csvName;
                            break;
                        }
                    }
                }
                
                if (sources !== undefined && sources > 0) {
                    const centroid = symbolPath.centroid(feature);
                    if (!isNaN(centroid[0]) && !isNaN(centroid[1])) {
                        symbolData.push({
                            country: geoCountryName,
                            csvName: matchedName,
                            sources: sources,
                            centroid: centroid,
                            radius: radiusScale(sources)
                        });
                        matchedCount++;
                    }
                }
            });
            
            console.log(`Matched ${matchedCount} countries with sources data`);
            console.log("Sample symbol data:", symbolData.slice(0, 5));
            
            // Sort symbol data by sources (descending) so largest circles are drawn first
            symbolData.sort((a, b) => b.sources - a.sources);
            console.log("Data sorted - largest to smallest:", symbolData.slice(0, 5).map(d => `${d.country}: ${d.sources}`));
            
            // Draw circles (no hover events on circles anymore)
            const circles = symbolSvg.select("#symbols-group")
                .selectAll(".source-circle")
                .data(symbolData)
                .enter()
                .append("circle")
                .attr("class", "source-circle")
                .attr("cx", d => d.centroid[0])
                .attr("cy", d => d.centroid[1])
                .attr("r", d => d.radius)
                .attr("data-original-radius", d => d.radius)
                .style("pointer-events", "none"); // Disable pointer events on circles
            
            // Add legend
            drawSymbolLegend(maxSources);
            
            console.log("Symbol map drawing completed");
        }

        function drawSymbolLegend(maxSources) {
            // Create legend group - positioned on the left side
            const legend = symbolSvg.append("g")
                .attr("class", "symbol-legend")
                .attr("transform", "translate(30, 80)");
            
            // Create legend items with proper spacing - reversed order (highest to lowest)
            const legendValues = [
                maxSources,
                Math.round(maxSources * 0.8),
                Math.round(maxSources * 0.4), 
                Math.round(maxSources * 0.1)
            ].filter(v => v > 0);
            
            console.log("Legend values:", legendValues);
            
            // Calculate the largest circle radius for proper spacing
            const maxRadius = radiusScale(maxSources);
            const itemSpacing = Math.max(maxRadius * 2 + 15, 40); // Ensure no overlap with extra padding
            const legendHeight = legendValues.length * itemSpacing + 35;
            
            // // Legend background - adjusted for vertical layout
            // legend.append("rect")
            //     .attr("x", -30)                
            //     .attr("y", -15)
            //     .attr("width", 140)
            //     .attr("height", legendHeight)
            //     .attr("fill", "rgba(255, 255, 255, 0.95)")
            //     .attr("stroke", "#ddd")
            //     .attr("stroke-width", 1)
            //     .attr("rx", 5);
            
            // Legend title
            legend.append("text")
                .attr("class", "legend-title-text")
                .attr("x", -25)
                .attr("y", -20)
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("font-family", "'Fira Sans', sans-serif")
                .style("fill", "#2c3e50")
                .text("Sources per Country");
            
            const legendItems = legend.selectAll(".legend-item-symbol")
                .data(legendValues)
                .enter()
                .append("g")
                .attr("class", "legend-item-symbol")
                .attr("transform", (d, i) => `translate(0, ${25 + i * itemSpacing})`);
            
            // Legend circles - positioned to avoid overlap
            legendItems.append("circle")
                .attr("class", "legend-circle")
                .attr("cx", d => 20) // Dynamic x position based on radius
                .attr("cy", 0)
                .attr("r", d => radiusScale(d))
                .style("fill", "#b82f2f")
                .style("fill-opacity", 0.7)
                .style("stroke", "#8a2323")
                .style("stroke-width", "1px");
            
            // Legend text - positioned after the largest possible circle
            legendItems.append("text")
                .attr("x", maxRadius + 45)
                .attr("y", 0)
                .attr("dy", "0.35em")
                .style("font-size", "12px")
                .style("font-family", "'Fira Sans', sans-serif")
                .style("fill", "#333")
                .text(d => d.toLocaleString());
        }

        function showSymbolTooltip(event, d) {
            let tooltip = d3.select("#symbol-tooltip");
            if (tooltip.empty()) {
                tooltip = d3.select("body")
                    .append("div")
                    .attr("id", "symbol-tooltip")
                    .attr("class", "symbol-tooltip")
                    .style("opacity", 0);
            }
            
            tooltip.html(`
                <div class="country-name">${d.country}</div>
                <div><strong>Total Sources:</strong> ${d.sources.toLocaleString()}</div>
                <div style="font-size: 11px; margin-top: 5px; opacity: 0.8;">
                    Circle area proportional to source count
                </div>
            `)
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 10) + "px")
            .transition()
            .duration(200)
            .style("opacity", 1);
        }

        function hideSymbolTooltip() {
            d3.select("#symbol-tooltip")
                .transition()
                .duration(200)
                .style("opacity", 0);
        }

        // Initialize symbol map when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a bit to ensure other maps are initialized first
            setTimeout(() => {
                initSymbolMap();
            }, 1000);
        });
    </script>
</body>
</html>